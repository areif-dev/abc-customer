use csv::StringRecord;
// https://apis.usps.com/addresses/v3/city-state
use derive_builder::Builder;
use std::{collections::HashMap, fmt::Display, path::Path, str::FromStr};

#[derive(Debug, Clone, PartialEq, Builder)]
#[builder(setter(into))]
pub struct AbcCustomer {
    code: String,
    name: String,
    address: Option<String>,
    zip: Option<String>,
    email: Option<String>,
    #[builder(default = Vec::new())]
    phone: Vec<String>,
    terms: PaymentTerms,
    tax_code: String,
    tin: Option<String>,
    jdf_id: Option<String>,
}

pub type AbcCustomersByCode = HashMap<String, AbcCustomer>;

#[derive(Debug, Clone, PartialEq)]
pub enum PaymentTerms {
    /// Full payment is due at the time of product or service delivery
    CashOnDelivery,
    /// Full payment is due within the specified number of days from the date of the invoice
    Net(u32),
}

pub type Context = String;

#[derive(Debug)]
pub enum AbcCustomerError {
    BuilderError(AbcCustomerBuilderError, Context),
    ParsePaymentTermsError(String, Context),
    CsvError(csv::Error, Context),
}

pub trait WithContext<T> {
    /// If `self` is `Ok`, returns the value unchanged.
    /// If `self` is `Err`, appends `ctx` to the error’s internal `Context`
    /// and returns the mutated error.
    fn with_context(self, ctx: &str) -> Result<T, AbcCustomerError>;
}

impl AbcCustomer {
    /// Create a map of skus to [`AbcCustomer`]s by parsing ABC database export files.
    ///
    /// In order to run a database export, run report 7-10, select "C" (Customer) as the file to export. All
    /// other parameters can be skipped or left as default. Run the report to the Screen. After a
    /// few seconds, two files should be created at
    /// C:\ABC Software\Database Export\Company001\Data\customer.data and
    /// C:\ABC Software\Database Export\Company001\Data\customer_posted.data.
    ///
    /// # Arguments
    /// * `customer_path` - The path to the item.data file generated by the db export. This will
    /// probably be C:\ABC Software\Database Export\Company001\Data\customer.data.
    ///
    /// # Returns
    /// A [`HashMap`] of ABC customer IDs to the [`AbcCustomer`] they belong to
    ///
    /// # Errors
    /// The data files are long, and ABC does not always produce them correctly. Therefore, if any
    /// required fields are missing or if certain values cannot be parsed,
    /// then an [`ParseCustomerError`] will be returned
    pub fn from_db_export(
        customer_path: impl AsRef<Path>,
    ) -> Result<AbcCustomersByCode, AbcCustomerError> {
        fn parse_record(row: StringRecord) -> Result<(String, AbcCustomer), AbcCustomerError> {
            let code = row.get(0).ok_or((
                AbcCustomerBuilderError::UninitializedField("code"),
                format!("failed setting customer code. row is {:?}", row),
            ))?;
            let name = row.get(1).ok_or((
                AbcCustomerBuilderError::UninitializedField("name"),
                format!("failed setting customer name. row is {:?}", row),
            ))?;
            let address = row.get(3).map_or(None, |a| {
                if a.is_empty() {
                    None
                } else {
                    Some(a.to_string())
                }
            });
            let zip = row.get(4).map_or(None, |z| {
                if z.is_empty() {
                    None
                } else {
                    Some(z.to_string())
                }
            });
            let email = row.get(6).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });
            let tax = row
                .get(11)
                .map_or("PA", |e| if e.is_empty() { "PA" } else { e });

            // Phone numbers may exist at any of indexes 7, 27, 34
            let phone: Vec<String> = [7usize, 27, 34]
                .iter()
                .filter_map(|i| {
                    row.get(*i).map_or(None, |s| {
                        if s.is_empty() {
                            None
                        } else {
                            Some(s.to_string())
                        }
                    })
                })
                .collect();
            let terms: PaymentTerms = row
                .get(15)
                .unwrap_or("")
                .parse()
                .unwrap_or(PaymentTerms::CashOnDelivery);
            let tin = row.get(31).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });
            let jdf_id = row.get(36).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });

            Ok((
                code.to_owned(),
                AbcCustomerBuilder::default()
                    .code(code)
                    .name(name)
                    .address(address)
                    .zip(zip)
                    .email(email)
                    .phone(phone)
                    .terms(terms)
                    .tax_code(tax)
                    .jdf_id(jdf_id)
                    .tin(tin)
                    .build()?,
            ))
        }

        let mut customer_data = csv::ReaderBuilder::new()
            .delimiter(b'\t')
            .has_headers(false)
            .from_path(customer_path)
            .map_err(|e| AbcCustomerError::from(e))
            .with_context(&format!("customer.data file failed to open"))?;

        let mut customers = HashMap::new();
        for row in customer_data.records() {
            let row = row?;
            let (code, customer) = parse_record(row)?;
            customers.insert(code.to_string(), customer);
        }
        Ok(customers)
    }
}

impl FromStr for PaymentTerms {
    type Err = AbcCustomerError;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        let lower = value.to_lowercase();
        if lower.contains("cash") {
            return Ok(PaymentTerms::CashOnDelivery);
        }
        if lower.contains("net") {
            let days = lower
                .chars()
                .filter(|c| c.is_digit(10))
                .collect::<String>()
                .parse::<u32>()
                .map_err(|e| {
                    AbcCustomerError::ParsePaymentTermsError(
                        e.to_string(),
                        format!(
                            "parsing payment terms failed. Net due days could not be read from {}",
                            value
                        ),
                    )
                })?;
            return Ok(PaymentTerms::Net(days));
        }
        Err(AbcCustomerError::ParsePaymentTermsError(
            format!("could not parse valid payment terms from {}", value),
            format!("could not parse valid payment terms from {}", value),
        ))
    }
}

impl AbcCustomerError {
    /// Prepend additional context to the error’s stored [`Context`].
    ///
    /// The new context is placed **before** the existing one and separated
    /// by `" - "`, e.g. `"new" - "old"` -> `"new - old"`.
    pub fn add_context(&mut self, context: &str) {
        // Helper that prepends the new fragment to an existing `String`.
        fn prepend(existing: &mut Context, new: &str) {
            // If the existing context is empty we just replace it;
            // otherwise we keep the separator.
            if existing.is_empty() {
                *existing = new.to_string();
            } else {
                let combined = format!("{} - {}", new, existing);
                *existing = combined;
            }
        }

        match self {
            AbcCustomerError::BuilderError(_, ctx) => prepend(ctx, context),
            AbcCustomerError::ParsePaymentTermsError(_, ctx) => prepend(ctx, context),
            AbcCustomerError::CsvError(_, ctx) => prepend(ctx, context),
        }
    }
}

impl Display for AbcCustomerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let inner_message = match self {
            Self::BuilderError(_, c) => {
                format!("problem building customer info: {}", c)
            }
            Self::ParsePaymentTermsError(_, c) => {
                format!("problem parsing payment terms: {}", c)
            }
            Self::CsvError(_, c) => {
                format!("problem parsing csv data: {}", c)
            }
        };
        write!(f, "Error in AbcCustomer lib: {}", inner_message)
    }
}

impl From<(AbcCustomerBuilderError, Context)> for AbcCustomerError {
    fn from((inner, context): (AbcCustomerBuilderError, Context)) -> Self {
        Self::BuilderError(inner, context)
    }
}

impl From<(csv::Error, Context)> for AbcCustomerError {
    fn from((inner, context): (csv::Error, Context)) -> Self {
        Self::CsvError(inner, context)
    }
}

impl From<csv::Error> for AbcCustomerError {
    fn from(value: csv::Error) -> Self {
        AbcCustomerError::CsvError(value, String::new())
    }
}

impl From<AbcCustomerBuilderError> for AbcCustomerError {
    fn from(value: AbcCustomerBuilderError) -> Self {
        AbcCustomerError::BuilderError(value, String::new())
    }
}

impl<T> WithContext<T> for Result<T, AbcCustomerError> {
    fn with_context(self, ctx: &str) -> Result<T, AbcCustomerError> {
        self.map_err(|mut e| {
            e.add_context(ctx);
            e
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parser() {
        let customer_path = "./customer.data";
        let customers = AbcCustomer::from_db_export(customer_path).unwrap();
        let known_customers = AbcCustomersByCode::from([
            (
                ".CASH".to_string(),
                AbcCustomerBuilder::default()
                    .code(".CASH")
                    .name("Cash Sale")
                    .address(None)
                    .zip(None)
                    .tax_code("PA")
                    .tin(None)
                    .email(Some("something@nothing.com".to_string()))
                    .jdf_id(None)
                    .terms("CASH")
                    .build()
                    .unwrap(),
            ),
            (
                "SOMECODE".to_string(),
                AbcCustomerBuilder::default()
                    .code("SOMECODE")
                    .name("SOME COMPANY")
                    .address(Some("1119 CENTRE AVE".to_string()))
                    .email(None)
                    .zip(Some("19601".to_string()))
                    .phone(["(123)456-7890".to_string()])
                    .tax_code("PA/")
                    .terms("NET 30")
                    .tin(Some("123456789".to_string()))
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
            (
                "OTHERCODE".to_string(),
                AbcCustomerBuilder::default()
                    .code("OTHERCODE")
                    .name("OTHER COMPANY")
                    .address(Some("7180 BERNVILLE RD".to_string()))
                    .zip(Some("19506".to_string()))
                    .phone(["(987)654-3210".to_string(), "(123)456-7890".to_string()])
                    .email(Some("ree@ree.ree".to_string()))
                    .tax_code("PA")
                    .terms("NET30")
                    .tin(None)
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
            (
                "SURGI 0".to_string(),
                AbcCustomerBuilder::default()
                    .code("SURGI 0")
                    .name("SURNAME, GIVENNAME")
                    .address(Some("300 PENN VALLEY RD".to_string()))
                    .zip(Some("19506".to_string()))
                    .email(None)
                    .phone(["(321)195-5731".to_string()])
                    .tax_code("PA")
                    .terms("CASH")
                    .tin("123456789".to_string())
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
        ]);
        for (code, customer) in customers {
            assert_eq!(&customer, known_customers.get(&code).unwrap());
        }
    }
}

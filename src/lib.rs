use derive_builder::Builder;
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Builder)]
#[builder(setter(into))]
pub struct AbcCustomer {
    code: String,
    name: String,
    address: Option<String>,
    zip: Option<String>,
    email: Option<String>,
    #[builder(default = Vec::new())]
    phone: Vec<String>,
    terms: String,
    tax_code: String,
    tin: Option<String>,
    jdf_id: Option<String>,
}

#[derive(Debug)]
pub enum ParseCustomerError {
    /// An error caused by the csv parser.
    CsvError(csv::Error),
    /// A field required by [`AbcCustomer`] is missing from the csv file. Value 0 is the name of the
    /// field that is missing. Value 1 is the row of the file that failed
    MissingField(&'static str, usize),
    /// Covers any additional errors that arise while parsing. Value 0 should be used to provide
    /// context to the error such as the row that the error occurred on
    Custom(String),
    BuilderError(AbcCustomerBuilderError),
}

pub type AbcCustomersByCode = HashMap<String, AbcCustomer>;

impl AbcCustomer {
    /// Create a map of skus to [`AbcCustomer`]s by parsing ABC database export files.
    ///
    /// In order to run a database export, run report 7-10, select "C" (Customer) as the file to export. All
    /// other parameters can be skipped or left as default. Run the report to the Screen. After a
    /// few seconds, two files should be created at
    /// C:\ABC Software\Database Export\Company001\Data\customer.data and
    /// C:\ABC Software\Database Export\Company001\Data\customer_posted.data.
    ///
    /// # Arguments
    /// * `customer_path` - The path to the item.data file generated by the db export. This will
    /// probably be C:\ABC Software\Database Export\Company001\Data\customer.data.
    ///
    /// # Returns
    /// A [`HashMap`] of ABC customer IDs to the [`AbcCustomer`] they belong to
    ///
    /// # Errors
    /// The data files are long, and ABC does not always produce them correctly. Therefore, if any
    /// required fields are missing or if certain values cannot be parsed,
    /// then an [`ParseCustomerError`] will be returned
    pub fn from_db_export(customer_path: &str) -> Result<AbcCustomersByCode, ParseCustomerError> {
        let mut customer_data = csv::ReaderBuilder::new()
            .delimiter(b'\t')
            .has_headers(false)
            .from_path(customer_path)?;

        let mut i = 0;
        let mut customers = HashMap::new();
        while let Some(row) = customer_data.records().next() {
            i += 1;
            let row = row?;
            let code = row
                .get(0)
                .ok_or(ParseCustomerError::MissingField("code", i))?;
            let name = row
                .get(1)
                .ok_or(ParseCustomerError::MissingField("name", i))?;
            let address = row.get(3).map(str::to_string);
            let zip = row.get(4).map(str::to_string);
            let email = row.get(6).map(str::to_string);
            let tax = row.get(11).unwrap_or("PA");
            // Phone numbers may exist at any of indexes 7, 27, 34
            let phone: Vec<String> = [7, 27, 34]
                .iter()
                .filter_map(|i| row.get(*i))
                .map(str::to_string)
                .collect();
            let terms = row.get(15).unwrap_or("CASH");
            let tin = row.get(31).map(str::to_string);
            let jdf_id = row.get(36).map(str::to_string);

            customers.insert(
                code.to_string(),
                AbcCustomerBuilder::default()
                    .code(code)
                    .name(name)
                    .address(address)
                    .zip(zip)
                    .email(email)
                    .phone(phone)
                    .terms(terms)
                    .tax_code(tax)
                    .jdf_id(jdf_id)
                    .tin(tin)
                    .build()?,
            );
        }
        Ok(customers)
    }
}

impl std::fmt::Display for ParseCustomerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let inner_message = match self {
            Self::MissingField(field, row) => {
                format!("Missing field `{}` in row {}", field, row)
            }
            Self::CsvError(e) => format!("{}", e),
            Self::BuilderError(e) => format!("{}", e),
            Self::Custom(e) => format!("{}", e),
        };
        write!(f, "Failed to parse Customer file due to {}", inner_message)
    }
}

impl std::error::Error for ParseCustomerError {}

impl From<csv::Error> for ParseCustomerError {
    fn from(value: csv::Error) -> Self {
        Self::CsvError(value)
    }
}

impl From<AbcCustomerBuilderError> for ParseCustomerError {
    fn from(value: AbcCustomerBuilderError) -> Self {
        Self::BuilderError(value)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parser() {
        let customer_path = "./customer.data";
        let customers = AbcCustomer::from_db_export(customer_path).unwrap();
        assert_eq!(
            customers,
            AbcCustomersByCode::from([
                (
                    "123456".to_string(),
                    AbcCustomer::new()
                        .with_sku("123456")
                        .with_desc("PRODUCT A")
                        .add_upc(Gtin::nonstrict_new("85875500014"))
                        .with_cost(Decimal::new(123, 2))
                        .with_stock(0.00)
                        .with_list(Decimal::new(599, 2))
                        .with_last_sold(NaiveDate::from_str("2024-11-16").unwrap())
                        .add_alt_sku("ALT")
                        .build()
                        .unwrap()
                ),
                (
                    "ABC123".to_string(),
                    AbcCustomer::new()
                        .with_sku("ABC123")
                        .with_desc("PRODUCT B")
                        .with_stock(-6.0)
                        .with_list(Decimal::new(812, 2))
                        .with_cost(Decimal::new(523, 2))
                        .add_alt_sku("ALT SKU")
                        .with_group('A')
                        .unwrap()
                        .with_last_sold("2019-05-28".parse().unwrap())
                        .build()
                        .unwrap()
                )
            ])
        );
    }
}

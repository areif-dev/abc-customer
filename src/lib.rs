// https://apis.usps.com/addresses/v3/city-state
use derive_builder::Builder;
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Builder)]
#[builder(setter(into))]
pub struct AbcCustomer {
    code: String,
    name: String,
    address: Option<String>,
    zip: Option<String>,
    email: Option<String>,
    #[builder(default = Vec::new())]
    phone: Vec<String>,
    terms: String,
    tax_code: String,
    tin: Option<String>,
    jdf_id: Option<String>,
}

#[derive(Debug)]
pub enum ParseCustomerError {
    /// An error caused by the csv parser.
    CsvError(csv::Error),
    /// A field required by [`AbcCustomer`] is missing from the csv file. Value 0 is the name of the
    /// field that is missing. Value 1 is the row of the file that failed
    MissingField(&'static str, usize),
    /// Covers any additional errors that arise while parsing. Value 0 should be used to provide
    /// context to the error such as the row that the error occurred on
    Custom(String),
    BuilderError(AbcCustomerBuilderError),
}

pub type AbcCustomersByCode = HashMap<String, AbcCustomer>;

impl AbcCustomer {
    /// Create a map of skus to [`AbcCustomer`]s by parsing ABC database export files.
    ///
    /// In order to run a database export, run report 7-10, select "C" (Customer) as the file to export. All
    /// other parameters can be skipped or left as default. Run the report to the Screen. After a
    /// few seconds, two files should be created at
    /// C:\ABC Software\Database Export\Company001\Data\customer.data and
    /// C:\ABC Software\Database Export\Company001\Data\customer_posted.data.
    ///
    /// # Arguments
    /// * `customer_path` - The path to the item.data file generated by the db export. This will
    /// probably be C:\ABC Software\Database Export\Company001\Data\customer.data.
    ///
    /// # Returns
    /// A [`HashMap`] of ABC customer IDs to the [`AbcCustomer`] they belong to
    ///
    /// # Errors
    /// The data files are long, and ABC does not always produce them correctly. Therefore, if any
    /// required fields are missing or if certain values cannot be parsed,
    /// then an [`ParseCustomerError`] will be returned
    pub fn from_db_export(customer_path: &str) -> Result<AbcCustomersByCode, ParseCustomerError> {
        let mut customer_data = csv::ReaderBuilder::new()
            .delimiter(b'\t')
            .has_headers(false)
            .from_path(customer_path)?;

        let mut i = 0;
        let mut customers = HashMap::new();
        while let Some(row) = customer_data.records().next() {
            i += 1;
            let row = row?;
            let code = row
                .get(0)
                .ok_or(ParseCustomerError::MissingField("code", i))?;
            let name = row
                .get(1)
                .ok_or(ParseCustomerError::MissingField("name", i))?;
            let address = row.get(3).map_or(None, |a| {
                if a.is_empty() {
                    None
                } else {
                    Some(a.to_string())
                }
            });
            let zip = row.get(4).map_or(None, |z| {
                if z.is_empty() {
                    None
                } else {
                    Some(z.to_string())
                }
            });
            let email = row.get(6).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });
            let tax = row
                .get(11)
                .map_or("PA", |e| if e.is_empty() { "PA" } else { e });
            // Phone numbers may exist at any of indexes 7, 27, 34
            let phone: Vec<String> = [7usize, 27, 34]
                .iter()
                .filter_map(|i| {
                    row.get(*i).map_or(None, |s| {
                        if s.is_empty() {
                            None
                        } else {
                            Some(s.to_string())
                        }
                    })
                })
                .collect();
            let terms = row
                .get(15)
                .map_or("CASH", |e| if e.is_empty() { "CASH" } else { e });
            let tin = row.get(31).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });
            let jdf_id = row.get(36).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });

            let customer = AbcCustomerBuilder::default()
                .code(code)
                .name(name)
                .address(address)
                .zip(zip)
                .email(email)
                .phone(phone)
                .terms(terms)
                .tax_code(tax)
                .jdf_id(jdf_id)
                .tin(tin)
                .build()?;
            customers.insert(code.to_string(), customer);
        }
        Ok(customers)
    }
}

impl std::fmt::Display for ParseCustomerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let inner_message = match self {
            Self::MissingField(field, row) => {
                format!("Missing required field `{}` in row {}", field, row)
            }
            Self::CsvError(e) => format!("{}", e),
            Self::BuilderError(e) => format!("{}", e),
            Self::Custom(e) => format!("{}", e),
        };
        write!(f, "Failed to parse Customer file due to {}", inner_message)
    }
}

impl std::error::Error for ParseCustomerError {}

impl From<csv::Error> for ParseCustomerError {
    fn from(value: csv::Error) -> Self {
        Self::CsvError(value)
    }
}

impl From<AbcCustomerBuilderError> for ParseCustomerError {
    fn from(value: AbcCustomerBuilderError) -> Self {
        Self::BuilderError(value)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parser() {
        let customer_path = "./customer.data";
        let (customers, failed) = AbcCustomer::from_db_export(customer_path).unwrap();
        let known_customers = AbcCustomersByCode::from([
            (
                ".CASH".to_string(),
                AbcCustomerBuilder::default()
                    .code(".CASH")
                    .name("Cash Sale")
                    .address(None)
                    .zip(None)
                    .tax_code("PA")
                    .tin(None)
                    .email(Some("something@nothing.com".to_string()))
                    .jdf_id(None)
                    .terms("CASH")
                    .build()
                    .unwrap(),
            ),
            (
                "SOMECODE".to_string(),
                AbcCustomerBuilder::default()
                    .code("SOMECODE")
                    .name("SOME COMPANY")
                    .address(Some("1119 CENTRE AVE".to_string()))
                    .email(None)
                    .zip(Some("19601".to_string()))
                    .phone(["(123)456-7890".to_string()])
                    .tax_code("PA/")
                    .terms("NET 30")
                    .tin(Some("123456789".to_string()))
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
            (
                "OTHERCODE".to_string(),
                AbcCustomerBuilder::default()
                    .code("OTHERCODE")
                    .name("OTHER COMPANY")
                    .address(Some("7180 BERNVILLE RD".to_string()))
                    .zip(Some("19506".to_string()))
                    .phone(["(987)654-3210".to_string(), "(123)456-7890".to_string()])
                    .email(Some("ree@ree.ree".to_string()))
                    .tax_code("PA")
                    .terms("NET30")
                    .tin(None)
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
            (
                "SURGI 0".to_string(),
                AbcCustomerBuilder::default()
                    .code("SURGI 0")
                    .name("SURNAME, GIVENNAME")
                    .address(Some("300 PENN VALLEY RD".to_string()))
                    .zip(Some("19506".to_string()))
                    .email(None)
                    .phone(["(321)195-5731".to_string()])
                    .tax_code("PA")
                    .terms("CASH")
                    .tin("123456789".to_string())
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
        ]);
        for (code, customer) in customers {
            assert_eq!(&customer, known_customers.get(&code).unwrap());
        }
    }
}

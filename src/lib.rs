pub mod error;

use csv::StringRecord;
use derive_builder::Builder;
pub use error::Error;
use std::{collections::HashMap, path::Path, str::FromStr};

#[derive(Debug, Clone, PartialEq, Builder)]
#[builder(setter(into))]
pub struct AbcCustomer {
    code: String,
    name: String,
    address: Option<String>,
    zip: Option<String>,
    email: Option<String>,
    #[builder(default = Vec::new())]
    phone: Vec<String>,
    terms: PaymentTerms,
    tax_code: String,
    tin: Option<String>,
    jdf_id: Option<String>,
}

pub type AbcCustomersByCode = HashMap<String, AbcCustomer>;

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum PaymentTerms {
    /// Full payment is due at the time of product or service delivery
    CashOnDelivery,
    /// Full payment is due within the specified number of days from the date of the invoice
    Net(u32),
}

impl AbcCustomer {
    pub fn code(&self) -> String {
        self.code.to_string()
    }

    pub fn full_name(&self) -> String {
        self.name.to_string()
    }

    pub fn first_name(&self) -> Option<String> {
        if self.name.contains(",") {
            let split = self
                .name
                .split(",")
                .map(str::trim)
                .map(str::to_string)
                .collect::<Vec<String>>();
            let first_name = split.into_iter().rev().next()?;
            if first_name.is_empty() {
                return None;
            }
            return Some(first_name);
        }
        None
    }

    pub fn last_name(&self) -> Option<String> {
        if self.name.contains(",") {
            let mut split = self.name.split(",").map(str::trim).map(str::to_string);
            let last_name = split.next()?;
            if last_name.is_empty() {
                return None;
            }
            return Some(last_name);
        }
        None
    }

    pub fn company_name(&self) -> Option<String> {
        if !self.name.contains(",") {
            return Some(self.name.to_owned());
        }
        None
    }

    pub fn address(&self) -> Option<String> {
        self.address.to_owned()
    }

    pub fn zip(&self) -> Option<String> {
        self.zip.to_owned()
    }

    pub fn email(&self) -> Option<String> {
        self.email.to_owned()
    }

    pub fn phone(&self) -> Vec<String> {
        self.phone.to_owned()
    }

    pub fn terms(&self) -> PaymentTerms {
        self.terms
    }

    pub fn tax_code(&self) -> String {
        self.tax_code.to_string()
    }

    pub fn tin(&self) -> Option<String> {
        self.tin.to_owned()
    }

    pub fn jdf_id(&self) -> Option<String> {
        self.jdf_id.to_owned()
    }

    /// Create a map of skus to [`AbcCustomer`]s by parsing ABC database export files.
    ///
    /// In order to run a database export, run report 7-10, select "C" (Customer) as the file to export. All
    /// other parameters can be skipped or left as default. Run the report to the Screen. After a
    /// few seconds, two files should be created at
    /// C:\ABC Software\Database Export\Company001\Data\customer.data and
    /// C:\ABC Software\Database Export\Company001\Data\customer_posted.data.
    ///
    /// # Arguments
    /// * `customer_path` - The path to the item.data file generated by the db export. This will
    /// probably be C:\ABC Software\Database Export\Company001\Data\customer.data.
    ///
    /// # Returns
    /// A [`HashMap`] of ABC customer IDs to the [`AbcCustomer`] they belong to
    ///
    /// # Errors
    /// The data files are long, and ABC does not always produce them correctly. Therefore, if any
    /// required fields are missing or if certain values cannot be parsed,
    /// then an [`ParseCustomerError`] will be returned
    pub fn from_db_export(customer_path: impl AsRef<Path>) -> Result<AbcCustomersByCode, Error> {
        fn parse_record(row: StringRecord) -> Result<(String, AbcCustomer), Error> {
            let code = row.get(0).ok_or((
                AbcCustomerBuilderError::UninitializedField("code"),
                row.clone(),
            ))?;
            let name = row.get(1).ok_or((
                AbcCustomerBuilderError::UninitializedField("name"),
                row.clone(),
            ))?;
            let address = row.get(3).map_or(None, |a| {
                if a.is_empty() {
                    None
                } else {
                    Some(a.to_string())
                }
            });
            let zip = row.get(4).map_or(None, |z| {
                if z.is_empty() {
                    None
                } else {
                    Some(z.to_string())
                }
            });
            let email = row.get(6).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });
            let tax = row
                .get(11)
                .map_or("PA", |e| if e.is_empty() { "PA" } else { e });

            // Phone numbers may exist at any of indexes 7, 27, 34
            let phone: Vec<String> = [7usize, 27, 34]
                .iter()
                .filter_map(|i| {
                    row.get(*i).map_or(None, |s| {
                        if s.is_empty() {
                            None
                        } else {
                            Some(s.to_string())
                        }
                    })
                })
                .collect();
            let terms: PaymentTerms = row
                .get(15)
                .unwrap_or("")
                .parse()
                .unwrap_or(PaymentTerms::CashOnDelivery);
            let tin = row.get(31).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });
            let jdf_id = row.get(36).map_or(None, |e| {
                if e.is_empty() {
                    None
                } else {
                    Some(e.to_string())
                }
            });

            Ok((
                code.to_owned(),
                AbcCustomerBuilder::default()
                    .code(code)
                    .name(name)
                    .address(address)
                    .zip(zip)
                    .email(email)
                    .phone(phone)
                    .terms(terms)
                    .tax_code(tax)
                    .jdf_id(jdf_id)
                    .tin(tin)
                    .build()
                    .map_err(|e| (e, row))?,
            ))
        }

        let mut customer_data = csv::ReaderBuilder::new()
            .delimiter(b'\t')
            .has_headers(false)
            .from_path(customer_path)
            .map_err(|e| (e, "failed to open customer.data file"))?;

        let mut customers = HashMap::new();
        for row in customer_data.records() {
            let row = row.map_err(|e| {
                (
                    e,
                    "customer.data opened successfully, but could not read a particular record",
                )
            })?;
            let (code, customer) = parse_record(row)?;
            customers.insert(code.to_string(), customer);
        }
        Ok(customers)
    }
}

impl FromStr for PaymentTerms {
    type Err = Error;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        let lower = value.to_lowercase();
        if lower.contains("cash") {
            return Ok(PaymentTerms::CashOnDelivery);
        }
        if lower.contains("net") {
            let days = lower
                .chars()
                .filter(|c| c.is_digit(10))
                .collect::<String>()
                .parse::<u32>()
                .map_err(|e| {
                    Error::ParsePaymentTermsError(
                        format!(
                            "parsing payment terms failed. Net due days could not be read from {value}. Caused by {e}",
                        ),
                    )
                })?;
            return Ok(PaymentTerms::Net(days));
        }
        Err(Error::ParsePaymentTermsError(format!(
            "could not parse valid payment terms from {value}",
        )))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parser() {
        let customer_path = "./customer.data";
        let customers = AbcCustomer::from_db_export(customer_path).unwrap();
        let known_customers = AbcCustomersByCode::from([
            (
                ".CASH".to_string(),
                AbcCustomerBuilder::default()
                    .code(".CASH")
                    .name("Cash Sale")
                    .address(None)
                    .zip(None)
                    .tax_code("PA")
                    .tin(None)
                    .email(Some("something@nothing.com".to_string()))
                    .jdf_id(None)
                    .terms("CASH".parse::<PaymentTerms>().unwrap())
                    .build()
                    .unwrap(),
            ),
            (
                "SOMECODE".to_string(),
                AbcCustomerBuilder::default()
                    .code("SOMECODE")
                    .name("SOME COMPANY")
                    .address(Some("1119 CENTRE AVE".to_string()))
                    .email(None)
                    .zip(Some("19601".to_string()))
                    .phone(["(123)456-7890".to_string()])
                    .tax_code("PA/")
                    .terms("NET 30".parse::<PaymentTerms>().unwrap())
                    .tin(Some("123456789".to_string()))
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
            (
                "OTHERCODE".to_string(),
                AbcCustomerBuilder::default()
                    .code("OTHERCODE")
                    .name("OTHER COMPANY")
                    .address(Some("7180 BERNVILLE RD".to_string()))
                    .zip(Some("19506".to_string()))
                    .phone(["(987)654-3210".to_string(), "(123)456-7890".to_string()])
                    .email(Some("ree@ree.ree".to_string()))
                    .tax_code("PA")
                    .terms("NET30".parse::<PaymentTerms>().unwrap())
                    .tin(None)
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
            (
                "SURGI 0".to_string(),
                AbcCustomerBuilder::default()
                    .code("SURGI 0")
                    .name("SURNAME, GIVENNAME")
                    .address(Some("300 PENN VALLEY RD".to_string()))
                    .zip(Some("19506".to_string()))
                    .email(None)
                    .phone(["(321)195-5731".to_string()])
                    .tax_code("PA")
                    .terms("CASH".parse::<PaymentTerms>().unwrap())
                    .tin("123456789".to_string())
                    .jdf_id(None)
                    .build()
                    .unwrap(),
            ),
        ]);
        for (code, customer) in customers {
            assert_eq!(&customer, known_customers.get(&code).unwrap());
        }
    }
}
